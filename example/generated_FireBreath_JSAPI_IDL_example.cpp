
/*
 * AUTOGENERATED FILE
 * Generator: JSAPI_IDL_compiler.py
 */

#include <vector>
#include <string>
#include <iterator>
#include <algorithm>

#include "variant.h"
#include "variant_list.h"
#include "variant_map.h"
#include "APITypes.h"

#include "generated_FireBreath_JSAPI_IDL_example.h"

namespace TLSAjs
{

template <typename T>
inline FB::variant to_variant(const T& t)
{
    return FB::variant(t);
}

template <typename Inner>
inline FB::variant to_variant(const std::vector<Inner>& val)
{
    FB::VariantList vl;

    // Mac OS X C++ compiler doesn't like the std::transform, hence the for cycle
    // std::transform(val.begin(), val.end(), std::back_inserter(vl), &to_variant<Inner>);
    typename std::vector<Inner>::const_iterator it = val.begin();
    for (; it != val.end(); it++) {
        vl.push_back(to_variant(*it));
    }

    return vl;
}


template <>
inline FB::variant to_variant< ResolvedTLSA >(const ResolvedTLSA& val)
{
    FB::VariantMap vm;

    vm["certUsage"] = to_variant(val.certUsage);
    vm["selector"] = to_variant(val.selector);
    vm["matchingType"] = to_variant(val.matchingType);
    vm["association"] = to_variant(val.association);
    vm["associationHex"] = to_variant(val.associationHex);

    return vm;
}

ResolvedTLSA::ResolvedTLSA(CertUsage certUsage, Selector selector, MatchingType matchingType, const std::string& association, const std::string& associationHex):
	certUsage(certUsage),
	selector(selector),
	matchingType(matchingType),
	association(association),
	associationHex(associationHex)
{
}

FB::variant ResolvedTLSA::toVariant() const
{
	return to_variant(*this);
}



template <>
inline FB::variant to_variant< TLSALookupResult >(const TLSALookupResult& val)
{
    FB::VariantMap vm;

    vm["result"] = to_variant(val.result);
    vm["errorStr"] = to_variant(val.errorStr);
    vm["rcode"] = to_variant(val.rcode);
    vm["dnssecStatus"] = to_variant(val.dnssecStatus);
    vm["tlsa"] = to_variant(val.tlsa);

    return vm;
}

TLSALookupResult::TLSALookupResult(int result, const std::string& errorStr, int rcode, DNSSECStatus dnssecStatus, const std::vector< ResolvedTLSA >& tlsa):
	result(result),
	errorStr(errorStr),
	rcode(rcode),
	dnssecStatus(dnssecStatus),
	tlsa(tlsa)
{
}

FB::variant TLSALookupResult::toVariant() const
{
	return to_variant(*this);
}



template <>
inline FB::variant to_variant< DANEMatch >(const DANEMatch& val)
{
    FB::VariantMap vm;

    vm["successful"] = to_variant(val.successful);
    vm["abort"] = to_variant(val.abort);
    vm["errorStr"] = to_variant(val.errorStr);
    vm["derCert"] = to_variant(val.derCert);
    vm["pemCert"] = to_variant(val.pemCert);
    vm["tlsa"] = to_variant(val.tlsa);

    return vm;
}

DANEMatch::DANEMatch(bool successful, bool abort, const std::string& errorStr, const std::string& derCert, const std::string& pemCert, const ResolvedTLSA& tlsa):
	successful(successful),
	abort(abort),
	errorStr(errorStr),
	derCert(derCert),
	pemCert(pemCert),
	tlsa(tlsa)
{
}

FB::variant DANEMatch::toVariant() const
{
	return to_variant(*this);
}

	
}

