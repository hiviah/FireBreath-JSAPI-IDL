## Example of a YAML file for specifying classes that will be generated by 
## JSAPI_IDL_compiler.py.
##
## Usage: JSAPI_IDL_compiler.py FireBreath_JSAPI_IDL_example.yaml
##
## This specific example is taken from DANE/TLSA resolving plugin (see RFC 6698).

## Class definitions for structures passed inbetween plugin<->javascript
## Class names should begin with a capital letter to avoid clash with keywords.
##
## In C++, the generated classes can be used like: 
#
# #include "example/generated_FireBreath_JSAPI_IDL_example.h"
#
# using MyNamespace::JSAPIClass;
#
# JSAPIClass c; // default no-data constructor
# JSAPIClass c(value1, value2, ...) // set all values in constructor
#
# someVar = c.member1.submember2 //access to members
#
# return someVar.toVariant() // generate FB::variant to pass to javascript
#
# In javascript, the classes will appear like common JS objects, e.g.
#
# var c = plugin().someMethod() //get the result of a plugin call
# var something = c.member1.submember2 + 42; // do something with data
#
# You can inherit from the toplevel generated class in your code if you'd like
# to add some methods. But note that toVariant() must remain public.

#Will generate output_basefname.cpp, output_basefname.h and output_basefname.js
#in current dir
output_basefname: generated_FireBreath_JSAPI_IDL_example

# Optional includes that need to be inserted with "includefile.h" must have
# explicit apostrophes around, otherwise YAML will interpret it its string.
# (e.g. for including header with definition of a type)
includes:
    - '"APITypes.h"'

# Optional C++ namespace, defaults to empty namespace.
namespace: TLSAjs

# Enums must be toplevel so that we can export them to JS
# Will be available in javascript as EnumTypeName.FIELD
# Numerical values are not required, by default they start from 0 and increment
# by 1. It's possible to use identical values for more enum fields.
enums:
    DNSSECStatus:
        - INSECURE: 0
        - SECURE
        - BOGUS
    
    CertUsage:
        - CA_CERT_PIN: 0
        - EE_CERT_PIN: 1
        - CA_TA_ADDED: 2
        - EE_TA_ADDED: 3
        
    MatchingType:
        - EXACT: 0
        - SHA256: 1
        - SHA512: 2
    
    Selector:
        - FULL: 0
        - SPKI: 1

    DANEPolicy:
        - ALLOW_TYPE_01: 1
        - ALLOW_TYPE_23: 2

# Example of specifying a struct/class. Each indented subitem represents one
# "memberName: type"
#
# Currently supported types (C++ equivalents in brackets):
#   - int (int)
#   - bool (bool)
#   - string (std::string)
#   - list<Type> (std::vector<Type>)
#
# Keep the class definition order like you would in a .h file (e.g. if class
# ToplevelStuff has member of type Subaggregate, define Subaggregate first).

ResolvedTLSA:
    certUsage: CertUsage
    selector: Selector
    matchingType: MatchingType
    association: string
    associationHex: string # JS or FB doesn't seem to like the null char

# classes can be nested, you can use e.g. list of a class
TLSALookupResult:
    result: int
    errorStr: string
    rcode: int
    dnssecStatus: DNSSECStatus
    tlsa: list<ResolvedTLSA>

# You can put comments next to members, but currently they are not transferred
# to generated .h and .cpp.
DANEMatch:
    successful: bool #other fields are undefined unless successful==true
    abort: bool #true means that known bogus TLSA reply was on the wire
    errorStr: string #error message for abort or unsuccessful match
    derCert: string
    pemCert: string
    tlsa: ResolvedTLSA
